#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define VERTICES 5
#define INFINITO INT_MAX

// --- 1. ESTRUTURA PONDERADA ---
// A mesma estrutura com peso usada para o Dijkstra.
typedef struct No {
    int verticeDestino;
    int peso;
    struct No* proximo;
} No;

// Criação de Aresta (usando a função de Dijkstra)
void criarAresta(No* grafo[], int origem, int destino, int peso) {
    No* novo = (No*) malloc(sizeof(No));
    if (novo == NULL) {
        fprintf(stderr, "Erro de alocacao de memoria.\n");
        return;
    }
    novo->verticeDestino = destino;
    novo->peso = peso;
    novo->proximo = grafo[origem];
    grafo[origem] = novo;
}


// -----------------------------------------------------------------
// 2. ALGORITMO DE BELLMAN-FORD
// -----------------------------------------------------------------
int bellmanFord(No* grafo[], int numVertices, int origem) {
    // Array para armazenar a menor distância conhecida até cada vértice
    int distancias[numVertices]; 
    
    // 1. Inicialização: Distâncias e Predecessores
    for (int i = 0; i < numVertices; i++) {
        distancias[i] = INFINITO; 
    }
    distancias[origem] = 0; // Distância da origem para ela mesma é zero

    // 2. Relaxamento Repetitivo (V - 1 vezes)
    // Este é o coração do algoritmo. Garante que o menor caminho é encontrado, 
    // pois o menor caminho tem no máximo |V|-1 arestas.
    for (int i = 1; i < numVertices; i++) {
        // Percorre TODOS os vértices U
        for (int u = 0; u < numVertices; u++) {
            // Percorre todas as arestas que SAEM de U
            No* adjacente = grafo[u];
            while (adjacente != NULL) {
                int v = adjacente->verticeDestino;
                int peso_aresta = adjacente->peso;

                // Processo de RELAXAMENTO (Atualização da Distância):
                // Se a distância para U é finita E o caminho através de U é menor que a distância registrada para V:
                if (distancias[u] != INFINITO && distancias[u] + peso_aresta < distancias[v]) {
                    distancias[v] = distancias[u] + peso_aresta;
                }
                adjacente = adjacente->proximo;
            }
        }
    }

    // 3. Verificação de Ciclos Negativos (O Vantagem Chave do Bellman-Ford)
    // Se o relaxamento ainda funcionar na V-ésima iteração, existe um ciclo negativo.
    for (int u = 0; u < numVertices; u++) {
        No* adjacente = grafo[u];
        while (adjacente != NULL) {
            int v = adjacente->verticeDestino;
            int peso_aresta = adjacente->peso;

            if (distancias[u] != INFINITO && distancias[u] + peso_aresta < distancias[v]) {
                printf("\n--- ALERTA: CICLO NEGATIVO DETECTADO! ---\n");
                printf("O algoritmo nao pode garantir o menor caminho.\n");
                return 0; // Retorna 0 (indicando erro/ciclo negativo)
            }
            adjacente = adjacente->proximo;
        }
    }
    
    // 4. Impressão do Resultado (Se não houver ciclo negativo)
    printf("\n--- Menor Caminho a partir da Origem %d (BELLMAN-FORD) ---\n", origem);
    for (int i = 0; i < numVertices; i++) {
        if (distancias[i] == INFINITO) {
            printf("Vertice %d: Inalcancavel\n", i);
        } else {
            printf("Vertice %d: %d\n", i, distancias[i]);
        }
    }
    printf("----------------------------------------------------------\n");
    return 1; // Retorna 1 (indicando sucesso)
}


// ----------------------------------------------------
// 3. FUNÇÕES DE LIMPEZA E MAIN 
// ----------------------------------------------------

void desalocarGrafo(No* grafo[], int numVertices) {
    for (int i = 0; i < numVertices; i++) {
        No* atual = grafo[i];
        while (atual != NULL) {
            No* temp = atual;
            atual = atual->proximo;
            free(temp); 
        }
        grafo[i] = NULL; 
    }
    printf("Memoria do grafo desalocada com sucesso.\n");
}

int main() {
    No* grafo[VERTICES]; 

    // Inicialização
    for (int i = 0; i < VERTICES; i++) {
        grafo[i] = NULL; 
    }

    // CRIAÇÃO DE CONEXÕES PONDERADAS (Origem, Destino, Peso)
    // Exemplo Simples com PESO NEGATIVO (sem ciclo negativo)
    // 0 -> 1 (Peso 6)
    // 0 -> 2 (Peso 7)
    // 1 -> 3 (Peso 5)
    // 2 -> 3 (Peso -8) <-- Peso Negativo!
    // 1 -> 4 (Peso -4)
    // 4 -> 3 (Peso 7)
    
    criarAresta(grafo, 0, 1, 6);
    criarAresta(grafo, 0, 2, 7);
    criarAresta(grafo, 1, 3, 5);
    criarAresta(grafo, 2, 3, -8); 
    criarAresta(grafo, 1, 4, -4);
    criarAresta(grafo, 4, 3, 7); 

    // 4. EXECUÇÃO DO BELLMAN-FORD
    bellmanFord(grafo, VERTICES, 0); 

    // 5. LIMPEZA
    desalocarGrafo(grafo, VERTICES);
    
    return 0;
}