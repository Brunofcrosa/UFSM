#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define VERTICES 6 // Pessoas de 0 a 5
#define INFINITO INT_MAX

// --- 1. ESTRUTURA BÁSICA ---
typedef struct No {
    int verticeDestino;     
    struct No* proximo;     
} No;

// --- 2. FILA (QUEUE) SIMPLES PARA BFS ---
int fila[VERTICES];
int frente = 0; 
int traseira = -1; 
int total_elementos = 0;

void enfileirar(int valor) {
    if (total_elementos < VERTICES) {
        traseira = (traseira + 1) % VERTICES;
        fila[traseira] = valor;
        total_elementos++;
    }
}

int desenfileirar() {
    int valor = -1;
    if (total_elementos > 0) {
        valor = fila[frente];
        frente = (frente + 1) % VERTICES;
        total_elementos--;
    }
    return valor;
}

int filaVazia() {
    return total_elementos == 0;
}

// ----------------------------------------------------
// 3. CRIAR ARESTA
// ----------------------------------------------------
void criarAresta(No* grafo[], int origem, int destino) {
    No* novo = (No*) malloc(sizeof(No));
    if (novo == NULL) {
        fprintf(stderr, "Erro de alocacao de memoria.\n");
        return;
    }
    novo->verticeDestino = destino;
    novo->proximo = grafo[origem]; 
    grafo[origem] = novo; 
}


// ----------------------------------------------------
// 4. BUSCA EM LARGURA (BFS com Distância)
// ----------------------------------------------------
// Encontra a menor distancia (menor número de passos) de 'inicio' para todos.
void calcularGrauSeparacao(No* grafo[], int numVertices, int inicio, int destino) {
    // Array para armazenar o número de passos (distância)
    int distancia[numVertices];
    
    // Inicialização
    for (int i = 0; i < numVertices; i++) {
        distancia[i] = INFINITO; // Distância inicial desconhecida
    }

    frente = 0; traseira = -1; total_elementos = 0; // Reinicia a fila
    
    distancia[inicio] = 0; // Distância da origem para ela mesma é 0
    enfileirar(inicio);
    
    printf("\n--- Grau de Separacao (Menor Caminho em Passos) ---\n");

    while (!filaVazia()) {
        int u = desenfileirar(); // Vértice atual
        
        // Se encontramos o destino, paramos e reportamos
        if (u == destino) {
            printf("A menor distancia da Pessoa %d para a Pessoa %d e: %d\n", 
                   inicio, destino, distancia[destino]);
            return;
        }

        // Percorre os vizinhos (v) de u
        No* adjacente = grafo[u];
        while (adjacente != NULL) {
            int v = adjacente->verticeDestino;
            
            // Se o vizinho V ainda nao foi visitado (distancia e INFINITO)
            if (distancia[v] == INFINITO) {
                // A distancia de V sera a distancia de U + 1 passo
                distancia[v] = distancia[u] + 1;
                enfileirar(v);
            }
            
            adjacente = adjacente->proximo;
        }
    }
    
    // Se o loop terminar sem encontrar o destino
    printf("Pessoa %d e Pessoa %d estao inalcancaveis (Distancia: INFINITO).\n", inicio, destino);
}


// ----------------------------------------------------
// MAIN (USANDO O ENUNCIADO CLÁSSICO)
// ----------------------------------------------------
int main() {
    No* grafo[VERTICES]; 

    for (int i = 0; i < VERTICES; i++) {
        grafo[i] = NULL; 
    }

    // Grafo (Lista de Adjacencia do Enunciado):
    // 0: [1, 2]
    // 1: [3]
    // 2: [4]
    // 3: [5]
    // 4: [3]
    // 5: []
    
    criarAresta(grafo, 0, 1);
    criarAresta(grafo, 0, 2);
    criarAresta(grafo, 1, 3);
    criarAresta(grafo, 2, 4);
    criarAresta(grafo, 4, 3); 

    // Executando o problema: Encontrar o menor caminho de 0 para 4
    calcularGrauSeparacao(grafo, VERTICES, 0, 4); 
    
    // Executando um segundo teste: de 0 para 5
    calcularGrauSeparacao(grafo, VERTICES, 0, 5); 

    // Desalocação
    for (int i = 0; i < VERTICES; i++) {
        No* atual = grafo[i];
        while (atual != NULL) {
            No* temp = atual;
            atual = atual->proximo;
            free(temp); 
        }
    }
    
    return 0;
}